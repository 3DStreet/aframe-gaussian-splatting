AFRAME.registerComponent("gaussian_splatting",{schema:{src:{type:"string",default:"train.splat"}},init:function(){this.el.sceneEl.renderer.setPixelRatio(1),fetch(this.data.src).then(data=>data.blob()).then(res=>res.arrayBuffer()).then(buffer=>{var size=new THREE.Vector2,focal=(this.el.sceneEl.renderer.getSize(size),size.y/2/Math.tan(this.el.sceneEl.camera.el.components.camera.data.fov/2*Math.PI/180));let u_buffer=new Uint8Array(buffer);112==u_buffer[0]&&108==u_buffer[1]&&121==u_buffer[2]&&10==u_buffer[3]&&(buffer=this.processPlyBuffer(buffer),u_buffer=new Uint8Array(buffer));let vertexCount=Math.floor(buffer.byteLength/32);var f_buffer=new Float32Array(buffer),matrices=(vertexCount>16777216/3&&(console.log("vertexCount limited to 4096*4096/3",vertexCount),vertexCount=Math.floor(16777216/3)),new Float32Array(16*vertexCount)),paddedCenterCovariances=new Float32Array(67108864),paddedColors=new Float32Array(67108864);for(let i=0;i<vertexCount;i++){var quat=new THREE.Quaternion((u_buffer[32*i+28+1]-128)/128,(u_buffer[32*i+28+2]-128)/128,-(u_buffer[32*i+28+3]-128)/128,(u_buffer[32*i+28]-128)/128),center=new THREE.Vector3(f_buffer[8*i+0],f_buffer[8*i+1],-f_buffer[8*i+2]),scale=new THREE.Vector3(f_buffer[8*i+3],f_buffer[8*i+3+1],f_buffer[8*i+3+2]),mtx=new THREE.Matrix4,quat=(mtx.makeRotationFromQuaternion(quat),mtx.transpose(),mtx.scale(scale),mtx.clone()),scale=(mtx.transpose(),mtx.premultiply(quat),mtx.setPosition(center),12*i);paddedCenterCovariances[0+scale]=center.x,paddedCenterCovariances[1+scale]=center.y,paddedCenterCovariances[2+scale]=center.z,paddedCenterCovariances[3+scale]=mtx.elements[0],paddedCenterCovariances[4+scale]=mtx.elements[1],paddedCenterCovariances[5+scale]=mtx.elements[2],paddedCenterCovariances[6+scale]=mtx.elements[5],paddedCenterCovariances[7+scale]=mtx.elements[6],paddedCenterCovariances[8+scale]=mtx.elements[10],paddedColors[0+(scale=4*i)]=u_buffer[32*i+24]/255,paddedColors[1+scale]=u_buffer[32*i+24+1]/255,paddedColors[2+scale]=u_buffer[32*i+24+2]/255,paddedColors[3+scale]=u_buffer[32*i+24+3]/255;for(let j=0;j<16;j++)matrices[16*i+j]=mtx.elements[j]}var buffer=new THREE.DataTexture(paddedCenterCovariances,4096,4096,THREE.RGBAFormat,THREE.FloatType),colorTexture=(buffer.needsUpdate=!0,new THREE.DataTexture(paddedColors,4096,4096,THREE.RGBAFormat,THREE.FloatType)),camera_mtx=(colorTexture.needsUpdate=!0,this.el.sceneEl.camera.el.object3D.matrixWorld.elements),camera_mtx=new Float32Array([camera_mtx[2],camera_mtx[6],camera_mtx[10]]),camera_mtx=this.sortSplats(matrices,camera_mtx),camera_mtx=new THREE.InstancedBufferAttribute(camera_mtx,1,!1),baseGeometry=(camera_mtx.setUsage(THREE.DynamicDrawUsage),new THREE.BufferGeometry),positionsArray=new Float32Array(18),positionsArray=new THREE.BufferAttribute(positionsArray,3),positionsArray=(baseGeometry.setAttribute("position",positionsArray),positionsArray.setXYZ(2,-2,2,0),positionsArray.setXYZ(1,2,2,0),positionsArray.setXYZ(0,-2,-2,0),positionsArray.setXYZ(5,-2,-2,0),positionsArray.setXYZ(4,2,2,0),positionsArray.setXYZ(3,2,-2,0),positionsArray.needsUpdate=!0,(new THREE.InstancedBufferGeometry).copy(baseGeometry));positionsArray.setAttribute("splatIndex",camera_mtx),positionsArray.instanceCount=vertexCount;const material=new THREE.ShaderMaterial({uniforms:{viewport:{value:new Float32Array([size.x,size.y])},focal:{value:focal},centerCovarianceTexture:{value:buffer},colorTexture:{value:colorTexture}},vertexShader:`
					out vec4 vColor;
					out vec2 vPosition;
					uniform vec2 viewport;
					uniform float focal;

					attribute uint splatIndex;
					uniform sampler2D centerCovarianceTexture;
					uniform sampler2D colorTexture;

					ivec2 getDataUV(in int stride, in int offset) {
						uint covarianceD = splatIndex * uint(stride) + uint(offset);
						return ivec2(covarianceD%uint(4096),covarianceD/uint(4096));
					}

					void main () {
						vec4 sampledCenterCovarianceA = texelFetch(centerCovarianceTexture, getDataUV(3, 0), 0);
						vec4 sampledCenterCovarianceB = texelFetch(centerCovarianceTexture, getDataUV(3, 1), 0);
						vec4 sampledCenterCovarianceC = texelFetch(centerCovarianceTexture, getDataUV(3, 2), 0);

						vec4 center = vec4(sampledCenterCovarianceA.xyz, 1);
						vec3 cov3D_M11_M12_M13 = vec3(sampledCenterCovarianceA.w, sampledCenterCovarianceB.xy);
						vec3 cov3D_M22_M23_M33 = vec3(sampledCenterCovarianceB.zw, sampledCenterCovarianceC.x);

						ivec2 colorUV = ivec2(splatIndex%uint(4096),splatIndex/uint(4096));
						vec4 sampledColor = texelFetch(colorTexture, colorUV, 0);

						// Adjust View Pose
						mat4 adjViewMatrix = inverse(viewMatrix);
						adjViewMatrix[0][1] *= -1.0;
						adjViewMatrix[1][0] *= -1.0;
						adjViewMatrix[1][2] *= -1.0;
						adjViewMatrix[2][1] *= -1.0;
						adjViewMatrix[3][1] *= -1.0;
						adjViewMatrix = inverse(adjViewMatrix);
						mat4 modelMatrix_fixy = modelMatrix;
						modelMatrix_fixy[3][1] *= -1.0;
						mat4 modelView = adjViewMatrix * modelMatrix_fixy;

						vec4 camspace = modelView * center;
						vec4 pos2d = projectionMatrix * mat4(1,0,0,0,0,-1,0,0,0,0,1,0,0,0,0,1) * camspace;

						float bounds = 1.2 * pos2d.w;
						if (pos2d.z < -pos2d.w || pos2d.x < -bounds || pos2d.x > bounds
							|| pos2d.y < -bounds || pos2d.y > bounds) {
							gl_Position = vec4(0.0, 0.0, 2.0, 1.0);
							return;
						}

						mat3 Vrk = mat3(
							cov3D_M11_M12_M13.x, cov3D_M11_M12_M13.y, cov3D_M11_M12_M13.z,
							cov3D_M11_M12_M13.y, cov3D_M22_M23_M33.x, cov3D_M22_M23_M33.y,
							cov3D_M11_M12_M13.z, cov3D_M22_M23_M33.y, cov3D_M22_M23_M33.z
						);

						mat3 J = mat3(
							focal / camspace.z, 0., -(focal * camspace.x) / (camspace.z * camspace.z), 
							0., -focal / camspace.z, (focal * camspace.y) / (camspace.z * camspace.z), 
							0., 0., 0.
						);

						mat3 W = transpose(mat3(modelView));
						mat3 T = W * J;
						mat3 cov = transpose(T) * Vrk * T;

						vec2 vCenter = vec2(pos2d) / pos2d.w;

						float diagonal1 = cov[0][0] + 0.3;
						float offDiagonal = cov[0][1];
						float diagonal2 = cov[1][1] + 0.3;

						float mid = 0.5 * (diagonal1 + diagonal2);
						float radius = length(vec2((diagonal1 - diagonal2) / 2.0, offDiagonal));
						float lambda1 = mid + radius;
						float lambda2 = max(mid - radius, 0.1);
						vec2 diagonalVector = normalize(vec2(offDiagonal, lambda1 - diagonal1));
						vec2 v1 = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;
						vec2 v2 = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);

						vColor = sampledColor;
						vPosition = position.xy;

						gl_Position = vec4(
							vCenter 
								+ position.x * v2 / viewport * 2.0 
								+ position.y * v1 / viewport * 2.0, pos2d.z / pos2d.w, 1.0);
					}
					`,fragmentShader:`
					in vec4 vColor;
					in vec2 vPosition;

					void main () {
						float A = -dot(vPosition, vPosition);
						if (A < -4.0) discard;
						float B = exp(A) * vColor.a;
						gl_FragColor = vec4(vColor.rgb, B);
					}
				`,blending:THREE.CustomBlending,blendSrcAlpha:THREE.OneFactor,depthTest:!0,depthWrite:!1,transparent:!1});window.addEventListener("resize",()=>{var size=new THREE.Vector2,focal=(this.el.sceneEl.renderer.getSize(size),size.y/2/Math.tan(this.el.sceneEl.camera.el.components.camera.data.fov/2*Math.PI/180));material.uniforms.viewport.value[0]=size.x,material.uniforms.viewport.value[1]=size.y,material.uniforms.focal.value=focal});let mesh=new THREE.Mesh(positionsArray,material,vertexCount);mesh.frustumCulled=!1,this.el.object3D.add(mesh),this.worker=new Worker(URL.createObjectURL(new Blob(["(",this.createWorker.toString(),")(self)"],{type:"application/javascript"}))),this.worker.postMessage({sortFunction:this.sortSplats.toString(),matrices:matrices.buffer},[matrices.buffer]),this.worker.onmessage=e=>{e=new Uint32Array(e.data.sortedIndexes);mesh.geometry.attributes.splatIndex.set(e),mesh.geometry.attributes.splatIndex.needsUpdate=!0,mesh.geometry.instanceCount=e.length,this.sortReady=!0},this.sortReady=!0})},tick:function(time,timeDelta){var camera_mtx;this.sortReady&&(this.sortReady=!1,camera_mtx=this.el.sceneEl.camera.el.object3D.matrixWorld.elements,camera_mtx=new Float32Array([camera_mtx[2],camera_mtx[6],camera_mtx[10]]),this.worker.postMessage({view:camera_mtx},[camera_mtx.buffer]))},createWorker:function(self){let sortFunction,matrices;self.onmessage=e=>{if(e.data.sortFunction&&(eval(e.data.sortFunction),sortFunction=sortSplats),e.data.matrices&&(matrices=new Float32Array(e.data.matrices)),e.data.view){const view=new Float32Array(e.data.view),sortedIndexes=sortFunction(matrices,view);self.postMessage({sortedIndexes:sortedIndexes},[sortedIndexes.buffer])}}},sortSplats:function sortSplats(matrices,view){var vertexCount=matrices.length/16;let maxDepth=-1/0,minDepth=1/0;var depthList=new Float32Array(vertexCount),sizeList=new Int32Array(depthList.buffer);for(let i=0;i<vertexCount;i++){var depth=-(view[0]*matrices[16*i+12]-view[1]*matrices[16*i+13]-view[2]*matrices[16*i+14]);(depthList[i]=depth)>maxDepth&&(maxDepth=depth),depth<minDepth&&(minDepth=depth)}var depthInv=65535/(maxDepth-minDepth),counts0=new Uint32Array(65536);for(let i=0;i<vertexCount;i++)sizeList[i]=(depthList[i]-minDepth)*depthInv|0,counts0[sizeList[i]]++;var starts0=new Uint32Array(65536);for(let i=1;i<65536;i++)starts0[i]=starts0[i-1]+counts0[i-1];var depthIndex=new Uint32Array(vertexCount);for(let i=0;i<vertexCount;i++)depthIndex[starts0[sizeList[i]]++]=i;return depthIndex},processPlyBuffer:function(inputBuffer){var ubuf=new Uint8Array(inputBuffer),ubuf=(new TextDecoder).decode(ubuf.slice(0,10240)),header_end_index=ubuf.indexOf("end_header\n");if(header_end_index<0)throw new Error("Unable to read .ply file header");var vertexCount=parseInt(/element vertex (\d+)\n/.exec(ubuf)[1]);console.log("Vertex Count",vertexCount);let row_offset=0,offsets={},types={};var prop,TYPE_MAP={double:"getFloat64",int:"getInt32",uint:"getUint32",float:"getFloat32",short:"getInt16",ushort:"getUint16",uchar:"getUint8"};for(prop of ubuf.slice(0,header_end_index).split("\n").filter(k=>k.startsWith("property "))){var[,type,name]=prop.split(" "),type=TYPE_MAP[type]||"getInt8";types[name]=type,offsets[name]=row_offset,row_offset+=parseInt(type.replace(/[^\d]/g,""))/8}console.log("Bytes per row",row_offset,types,offsets);let dataView=new DataView(inputBuffer,header_end_index+"end_header\n".length),row=0;var attrs=new Proxy({},{get(target,prop){if(types[prop])return dataView[types[prop]](row*row_offset+offsets[prop],!0);throw new Error(prop+" not found")}});console.time("calculate importance");let sizeList=new Float32Array(vertexCount);var size,opacity,sizeIndex=new Uint32Array(vertexCount);for(row=0;row<vertexCount;row++)sizeIndex[row]=row,types.scale_0&&(size=Math.exp(attrs.scale_0)*Math.exp(attrs.scale_1)*Math.exp(attrs.scale_2),opacity=1/(1+Math.exp(-attrs.opacity)),sizeList[row]=size*opacity);console.timeEnd("calculate importance"),console.time("sort"),sizeIndex.sort((b,a)=>sizeList[a]-sizeList[b]),console.timeEnd("sort");var buffer=new ArrayBuffer(32*vertexCount);console.time("build buffer");for(let j=0;j<vertexCount;j++){row=sizeIndex[j];var qlen,position=new Float32Array(buffer,32*j,3),scales=new Float32Array(buffer,32*j+12,3),rgba=new Uint8ClampedArray(buffer,32*j+12+12,4),rot=new Uint8ClampedArray(buffer,32*j+12+12+4,4);types.scale_0?(qlen=Math.sqrt(attrs.rot_0**2+attrs.rot_1**2+attrs.rot_2**2+attrs.rot_3**2),rot[0]=attrs.rot_0/qlen*128+128,rot[1]=attrs.rot_1/qlen*128+128,rot[2]=attrs.rot_2/qlen*128+128,rot[3]=attrs.rot_3/qlen*128+128,scales[0]=Math.exp(attrs.scale_0),scales[1]=Math.exp(attrs.scale_1),scales[2]=Math.exp(attrs.scale_2)):(scales[0]=.01,scales[1]=.01,scales[2]=.01,rot[0]=255,rot[1]=0,rot[2]=0,rot[3]=0),position[0]=attrs.x,position[1]=attrs.y,position[2]=attrs.z,types.f_dc_0?(rgba[0]=255*(.5+(qlen=.28209479177387814)*attrs.f_dc_0),rgba[1]=255*(.5+qlen*attrs.f_dc_1),rgba[2]=255*(.5+qlen*attrs.f_dc_2)):(rgba[0]=attrs.red,rgba[1]=attrs.green,rgba[2]=attrs.blue),types.opacity?rgba[3]=1/(1+Math.exp(-attrs.opacity))*255:rgba[3]=255}return console.timeEnd("build buffer"),buffer}});